import { createApi } from "@reduxjs/toolkit/query/react";
import { baseQuery } from "./base";
import { IResponseAnswer } from "../interfaces";
import { ISetup, ITemplate } from "../../shared/models/interfaces";
import { REPORTS_DICT } from "../../shared/models/constants";
import { groupBy } from "../../shared/utils/base";
import { handleCatchError } from "./helper";

// const removeRegexes = [
//   /Based on the available data,/i,
//   /Based on the given information, the company overview is as follows:/i,
//   /Based on the provided information,/,
//   /Here is a professional and presentable markdown report for .+ using the provided data:/i,
//   /Here is the generated professional report for .+ using the provided data:/i,
//   /Generated today [^:]+/,
//   /Here is the generated professional report for .+ using the provided data:/i,
//   /Here is a professional and presentable markdown report for .+ based on the provided data:/i,
//   /Based on the provided information, the company overview is as follows:/i,
//   /Based on the data provided, here is an executive summary for a commercial due diligence report on .+:/i,
//   /However, a comprehensive market analysis is not possible without additional financial and market data./i,
//   /This report was prepared by \[Your Name\] on for .+?\.\s*/,
//   /Here is the generated professional and presentable report for .+ using the provided data:/i,
//   /This report provides a financial analysis for .+ based on the company's annual report data./i,
//   /Here is the generated professional report for .+ based on the provided data:/i,
//   /Prepared by: \[Your name\]/i,
//   /This report was generated by AI assistant for .+ on . The data used for analysis was provided by the company./i,
//   /Here is the generated professional report for .+ based on the provided data:/i,
//   /Here is a draft executive summary for a [^:]+:/,
//   /Here is a draft executive summary for a [^:]+:/,
//   /Here is an executive summary for a [^:]+:/,
//   /Unfortunately I do not have enough context to provide an executive summary for a full commercial due diligence report based on the limited data provided./,
//   /Based on the provided data, here is an executive summary for a [^:]+:/,
//   /This report was generated on for .+ based on provided data./,
//   /Report generated on for .+ by \[your name\]/,
//   /Unfortunately the data provided does not contain enough information to generate a full executive summary for a financial due diligence report. However, here is a high-level overview based on the analysis reports provided:/,
//   /Here is a draft financial analysis report for STAF 7 using the provided data:/,
//   /Prepared by: Financial Analyst Date:/,
//   "*This report was prepared for STAF 7 on *",
// ];

export const reportApi = createApi({
  reducerPath: "reportApi",
  refetchOnFocus: true,
  baseQuery,
  tagTypes: ["Report"],
  endpoints: (builder) => ({
    getReport: builder.query<
      any,
      {
        reportId: number;
      }
    >({
      query: ({ reportId }) => `reports/${reportId}`,
      keepUnusedDataFor: 0,
      providesTags: ["Report"],
    }),

    updateReport: builder.mutation<
      any,
      {
        reportId: number;
        content: string;
        custom: Record<string, any>;
      }
    >({
      query: ({ reportId, content, custom }) => ({
        url: `reports/${reportId}`,
        method: "PUT",
        body: {
          data: content,
          custom,
        },
      }),
    }),

    saveReport: builder.mutation<
      any,
      {
        setupId: number;
        reportName: string;
        data: string;
        template?: string;
      }
    >({
      query: ({ setupId, reportName, data, template }) => ({
        url: `reports`,
        method: "POST",
        body: {
          graph_id: setupId,
          report_name: reportName,
          data,
          ...(template ? { template } : { is_template_with_content: false }),
        },
      }),
    }),

    getAnswer: builder.query<
      IResponseAnswer,
      {
        report: string;
        companyCode: string;
        companyName: string;
        question?: string;
      }
    >({
      query: ({ report, companyCode, companyName, question }) =>
        `${report}?companycode=${companyCode}&companyname=${companyName}${
          question ? "&question=" + question : ""
        }`,
    }),

    getChatWithData: builder.mutation<
      any,
      { setupId: number; content: string; question: string }
    >({
      query: ({ setupId, question, content = "" }) => ({
        url: `chatwithdata/${setupId}`,
        method: "POST",
        body: {
          question,
          data: content,
        },
      }),
    }),

    createReportTemplate: builder.mutation<
      any,
      { setupId: number; queryType: string; llm: string; formatJson?: any }
    >({
      query: ({ setupId, queryType, llm, formatJson }) => ({
        url: `${queryType}/${setupId}?llm=${llm}`,
        method: "POST",
        ...(!!formatJson && {
          body: {
            format_json: formatJson,
          },
        }),
      }),
    }),

    generateReport: builder.mutation<
      any,
      { setupId: number; queryType: string; template?: string; data?: string }
    >({
      async queryFn(args, queryApi) {
        const { setupId, queryType, template, data } = args;
        let dataContent: string;
        try {
          if (!data) {
            const jsonResponse = await queryApi.dispatch(
              reportApi.endpoints.createReportTemplate.initiate({
                setupId,
                queryType,
                llm: "OpenAI",
              })
            );
            if ("error" in jsonResponse) {
              throw jsonResponse.error;
            }

            dataContent = JSON.stringify({
              answer: jsonResponse.data.answer,
              data: jsonResponse.data.data,
            });
          } else {
            dataContent = data;
          }
          const templateResponse = await queryApi.dispatch(
            reportApi.endpoints.saveReport.initiate({
              data: dataContent,
              setupId,
              reportName: queryType,
              ...(template && {
                template: `<h1>${REPORTS_DICT[queryType].label} Report</h1>${template}`,
              }),
            })
          );
          if ("error" in templateResponse) {
            throw templateResponse.error;
          }
          const generatedId: number = templateResponse.data.new_id;

          return {
            data: generatedId,
          };
        } catch (err) {
          return handleCatchError(err, "generateReport");
        }
      },
    }),

    reGenerateReport: builder.mutation<
      any,
      { reportId: number; setupId: number; queryType: string; template: string }
    >({
      async queryFn(args, queryApi, _, apiBaseQuery) {
        const { reportId, setupId, queryType, template } = args;
        try {
          const jsonResponse = await queryApi.dispatch(
            reportApi.endpoints.createReportTemplate.initiate({
              setupId,
              queryType,
              llm: "OpenAI",
            })
          );
          if ("error" in jsonResponse) {
            throw jsonResponse.error;
          }

          const templateResponse = await apiBaseQuery({
            url: `reports/${reportId}/regenerate`,
            method: "POST",
            body: {
              data: JSON.stringify({
                answer: jsonResponse.data.answer,
                data: jsonResponse.data.data,
              }),
              template: `
                  <h1>${REPORTS_DICT[queryType].label} Report</h1>
                  ${template}`,
            },
          });
          if (templateResponse.error) {
            throw templateResponse.error;
          } else {
            const filledTemplate: string = (templateResponse.data as any)
              .filled_template;

            return {
              data: filledTemplate,
            };
          }
        } catch (err) {
          return handleCatchError(err, "reGenerateReport");
        }
      },
    }),
    generateCustomReport: builder.mutation<
      string,
      { setupId: number; template: string; data: string }
    >({
      query: ({ setupId, template, data }) => ({
        url: `reports/custom`,
        method: "POST",
        body: {
          graph_id: setupId,
          data,
          template,
        },
      }),
    }),

    markReport: builder.mutation<any, { reportId: number }>({
      query: ({ reportId }) => ({
        url: `reports/${reportId}/marked`,
        method: "PUT",
      }),
    }),

    deleteReport: builder.mutation<any, { reportId: number; viewMode: string }>(
      {
        query: ({ reportId }) => ({
          url: `reports/${reportId}`,
          method: "DELETE",
        }),
        invalidatesTags: ["Report"],
      }
    ),

    getReports: builder.query<any, { viewMode?: string }>({
      async queryFn({ viewMode = "active" }, __, ___, apiBaseQuery) {
        try {
          const setupsReponse = await apiBaseQuery({
            url: "graphs",
          });
          if (setupsReponse.error) {
            throw setupsReponse.error;
          }
          const reportsReponse = await apiBaseQuery({
            url: `reports?view_mode=${viewMode}`,
          });

          if (reportsReponse.error) {
            throw reportsReponse.error;
          }
          const updatedReports = (reportsReponse.data as any)
            .map((response: any) => {
              const graph = (setupsReponse.data as any).find(
                (setup: ISetup) => setup.id === +response.graph_id
              );
              if (graph) {
                return {
                  ...response,
                  ...(viewMode === "active" && {
                    report_name: response.report_name,
                  }),
                  graph_name: graph.name,
                };
              }
            })
            .filter((report: any) => report);

          const groups = groupBy("graph_name")(updatedReports);

          return {
            data: groups,
          };
        } catch (err) {
          return handleCatchError(err);
        }
      },
      keepUnusedDataFor: 0,
      providesTags: ["Report"],
    }),

    getCustomQuery: builder.mutation<
      string,
      { setupId: number; question: string; chatMode?: boolean }
    >({
      query: ({ setupId, question, chatMode }) => ({
        url: `customquery/${setupId}?chatmode=${chatMode}&llm=Anthropic`,
        method: "POST",
        body: { question },
      }),
      transformResponse: (response: any) => {
        const regex = /```[^`]+```/g;
        const finalResult: string = response.data.answer.replace(regex, "");
        return finalResult;
      },
    }),
    generateWarrantReport: builder.mutation<
      string,
      {
        setupId: number;
        question: string;
        reportName: string;
        chatMode?: boolean;
      }
    >({
      query: ({ setupId, reportName }) => ({
        url: `generate_report/${setupId}`,
        method: "POST",
        body: {
          data: JSON.stringify({
            answer: "",
            data: "",
          }),
          report_name: reportName,
          template: ``,
        },
      }),
      transformResponse: (response: any) => {
        return response.data.filled_template;
      },
    }),

    getChatHistory: builder.query<any, { setupId: number }>({
      query: ({ setupId }) => ({
        url: `chat_history/${setupId}`,
      }),
      transformResponse: (response: any) => {
        if (!response.length) return null;

        const updated = response
          .sort(
            (a: any, b: any) =>
              new Date(a.created_at).getTime() -
              new Date(b.created_at).getTime()
          )
          .map((record: any) => ({
            ...record,
            created_at: record.created_at.split("T")[0],
          }));

        // group by date
        const groups = groupBy("created_at")(updated);

        return groups;
      },
      keepUnusedDataFor: 0,
      providesTags: ["Report"],
    }),

    executeReportBackground: builder.mutation<
      any,
      {
        setupId: number;
        analysisType: string;
        llm?: string;
        rating?: number;
        report: ITemplate;
      }
    >({
      query: ({ setupId, analysisType, llm, rating, report }) => ({
        url: `execute_report_background/${setupId}`,
        method: "POST",
        body: {
          analysis_type: analysisType,
          llm,
          rating,
          report,
        },
      }),
    }),
  }),
});

export const {
  useLazyGetAnswerQuery,
  useGetCustomQueryMutation,
  useCreateReportTemplateMutation,
  useGenerateReportMutation,
  useReGenerateReportMutation,
  useGenerateCustomReportMutation,
  useGetReportsQuery,
  useLazyGetReportsQuery,
  useGetReportQuery,
  useLazyGetReportQuery,
  useDeleteReportMutation,
  useGetChatWithDataMutation,
  useGenerateWarrantReportMutation,
  useGetChatHistoryQuery,
  useUpdateReportMutation,
  useMarkReportMutation,
  useExecuteReportBackgroundMutation,
} = reportApi;
